# 데이터베이스
- 일정한 규칙 혹인 규약을 통해 구조화되어 저장되는 데이터 모음
- 실시간 접근과 동시 공유 가능
- DBMS: 데이터 베이스를 제어, 관리하는 통합 시스템
    - DB <-> DBMS <-> Application
    - 각 DBMS마다 정의된 쿼리 언어로 접근

#### 구성요소
1. 릴레이션
    - 데이터베이스에서 정보를 구분하여 저장하는 기본 단위
    - 관계형 DB의 테이블, 비관계형 DB의 콜렉션
        - MySQL: 레코드-테이블-DB
        - NoSQL: 도큐먼트-컬렉션-DB
1. 엔터티 (레코드, 튜플)
    - 사람, 장소, 물건, 사건, 개념 등 여러 개의 속성을 지닌 명사
    - 강한 엔터티/약한 엔터티(엔터티 존재 여부에 따라 종속적)
        - ex. 건물(강한 엔터티)-방(약한 엔터티)
1. 속성 (필드)
    - 릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보
        - '차'라는 엔터티 > 차 넘버, 바퀴 수, 차 색깔 등
1. 도메인
    - 릴레이션의 각각의 속성들이 가질 수 있는 값의 집합
        - 성별이라는 속성: {남, 여}

#### 관계
여러 개의 테이블이 있고, 이러한 테이블은 서로의 관계가 정의됨

1. 1:1 관계
    - 테이블이 하나씩 연결되어 있는 관계
    - 테이블을 두 개의 테이블로 나눠 테이블의 구조를 더 이해하기 쉽게 만듬
    - ex. 유저 테이블 - 유저 이메일 테이블
1. 1:N 관계
    - 테이블 하나에 여러 개의 테이블이 연결
    - ex. 유저 테이블 - 상품 테이블
1. N:M 관계
    - 테이블을 직접적으로 연결하여 구축하지는 않음
    - 1:N, 1:M 관계를 맺는 테이블 2개로 나누어 설정
    - ex. 학생 테이블 - 학생_강의 테이블 - 강의 테이블

#### 키
- 유일성: 중복되는 값이 없음
- 최소성: 필드를 조합하지 않고, 최소 필드만 써서 키 생성

1. 기본키
    - 최소성, 유일성 만족
    - 자연키: 자연스레 뽑다가 나오는 키. 언젠가는 변하는 속성
    - 인조키: 인위적으로 생성한 키. 변하지 않음. 유저ID
1. 후보키
    - 기본키가 될 수 있는 후보. 최소성, 유일성 만족
1. 대체키
    - 후보키가 두 개 이상일 경우 하나를 기본키도 지정하느 남은 후보키
1. 슈퍼키
    - 유일성을 갖춘 키
1. 외래키
    - 다른 테이블의 기본키를 그대로 참조하는 값
    - 중복되어도 괜찮음


## ERD와 정규화 과정

#### ERD (Entity Relationship Diagram)
- DB를 구축할 때 릴레이션 간의 관계들을 정의 (가장 기초적)
- 시스템의 요구 사항을 기반으로 작성
- 디버깅 또는 비지니스 프로세스 재설계 시 설계도 역할도 담당
- NoSQL DB를 표현할 수는 없음

### 정규화 과정
- 잘못된 종속 관계를 해결하기 위함
- 장점) 저장 공간을 효율적으로 사용하기 위해 릴레이션을 여러 개로 분리  
단점) 성능은 좋아질 수도 있고, 나빠질 수도 있음
- 원칙  
    - 같은 의미를 표현하는 릴레이션이지만 좀 더 좋은 구조로 구성
    - 자료의 중복성 감소
    - 독립적인 관계는 별개의 릴레이션으로 표현

#### 제 1정규형
- 더 이상 분해될 수 없는 **원자값(Atomic Value)**만으로 구성되어야 함
- 속성 값 중에서 한 개의 기본키에 대해 두 개 이상의 값을 가지는 **반복 집합**이 있으면 안 됨

유저번호|유저ID|수강명|성취도
---|---|---|---
1|홍철|{코딩테스트,프런트특강}|{90%,10%}
2|범석|{코드포스특강, DS특강}|{7%,8%}

유저번호|유저ID|수강명|성취도
---|---|---|---
1|홍철|코딩테스트|90%
1|홍철|프런트특강|10%
2|범석|코드포스특강|7%
2|범석|DS특강|8%

- 이상 현상
    - 삽입 이상: 유저를 찾을 때, 유저번호와 유저 ID를 알아야 한다. (불필요)
    - 수정 이상: 1번 학생이 유저ID를 변경할 때, '홍철'인 행을 모두 변경해야한다.
    - 삭제 이상: 홍철 학생이 코딩테스트 수강을 취소하면 해당 과목에 대한 정보가 모두 사라진다.

#### 제 2정규형
- 제 1정규형 + 부분함수의 종속성 제거
    - 종속성: 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것
- 기본키가 아닌 다른 속성이 결정자가 되서는 안 됨

유저번호|유저ID
---|---
1|홍철
2|범석

유저ID|수강명|성취도
---|---|---
홍철|코딩테스트|90%
홍철|프런트특강|10%
범석|코드포스특강|7%
범석|DS특강|8%

#### 제 3정규형
- 제 2정규형 + 기본키가 아닌 모든 속서이 이행적 함수 종속을 만족하지 않는 상태
    - 이행적 함수 종속: A>B, B>C일 때, A>C인 상태

유저ID|등급|할인율
---|---|---
홍철|A|70%
범석|B|50%
가영|C|30%

- 이상 현상
    - 삽입 이상: 새로운 등급을 삽입하고 싶지만 유저ID가 없으면 무결성에 위반됨
    - 수정 이상: 등급에 대한 할인율이 변경되면 일괄적으로 변경해야함
    - 삭제 이상: 유저ID를 삭제하고 싶은데, 어떤 등급을 가진 사람이 한 명이면 할인율이 사라짐

유저ID|등급
---|---
홍철|A
범석|B
가영|C

등급|할인율
---|---
A|70%
B|50%
C|30%

#### 보이스/코드 유형
- 제 3정규형 + 함수 종속 관계에서 모든 결정자가 후보키인 상태

유저ID|수강명|강사
--|--|--
홍철|코딩테스트|큰돌
홍철|MEVM|재엽
범석|코딩테스트|큰돌
범석|MEVN|가영

조건  
1. 각 수강명에 대해 한 학생은 오직 한 강사의 강의만 수강한다
1. 각 강사는 한 수강명만 담당한다. (강사: 결정자)
1. 한 수강명은 한 강사 또는 여러 강사가 담당할 수 있다. (강사: 후보키 X)

이상 현상
- 삽입 이상: 수강생이 없는 수강을 삽입이 불가능
- 수정 이상: 교수가 수강명을 변경하면 모두 변경
- 삭제 이상: 강사 정보 삭제가 유저 ID 삭제로 이어질 수 있음

유저ID|강사
--|--
홍철|큰돌
홍철|재엽
범석|큰돌
범석|가영

수강명|강사
--|--
코딩테스트|큰돌
MEVM|재엽
코딩테스트|큰돌
MEVN|가영

## 무결성과 트랜잭션

### 무결성
- 데이터의 정확성, 일관성, 유효성을 유지하는 것
- 현실 세계의 실제 값이 일치하는 지 신뢰에 바탕이 됨
- 종류
    1. 개체 무결성: 기본키로 선택된 필드는 빈 값 허용 X
    1. 참조 무결성: 서로 참조 관계의 두 테이블의 데이터는 항상 일관된 값 유지
    1. 고유 무결성: 속성에 대해 고유한 값을 가지도록 조건이 주어지면 속성 값은 모두 고유한 값을 가짐
    1. NULL 무결성: 속성에 대해 NULL 값을 가질 수 없도록 조건이 주어지면 NULL 값을 가질 수 없음

### 트랜잭션
- 논리적 기능을 수행하기 위한 작업의 단위
- ACID 특징을 가짐
    - 원자성, 일관성, 독립성, 지속성

#### 1. 원자성
- 모두 수행되었거나 수행되지 않았거나를 보장 (all or nothing)
- 외부 API 호출 주의 (만약 있다면 롤백 시 어떻게 해야 할 것인지 해결 방법 생각)
- 예시
    1. 홍철 잔고를 조회한다
    1. 홍철 잔고에서 500만원을 뺀다
    1. 규영에게 500만원을 넣는다  
    > 여기서 2번까지 수행되고, 3번이 수행되지 않으면 문제가 발생
- 데이터의 무결성 보장  
    - 커밋: 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어. 변경 내용이 영구적으로 저장됨
    - 롤백: 에러나 이슈로 인해 커밋 전 상태로 되돌림

#### 2. 일관성
- 허용된 방식으로만 데이터를 변경해야하는 것
- DB의 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야 함
- 예시  
홍철이가 통장에 0원이 있을 때, 500만원을 뺄 수 없음 (통장 잔액은 양수의 값을 가져야하기 때문)

#### 3. 격리성
- 트랜잭션 수행 시 서로 끼어들지 못하는 것
- 복수의 병렬 트랜잭션이 마치 순차적으로 실행되는 것처럼 동작

격리 수준|Dirty Read|Non-Repeatable Read|Phantom Read
--|--|--|--
Read Uncommitted|O|O|O
Read Committed|-|O|O
Repeatable Read|-|-|O
Serializable|-|-|-

격리 수준  
- Serializable
    - 트랜잭션을 순차적으로 진행
    - 트랜잭션이 동시에 같은 행에 접근할 수 없음
    - 성능이 떨어지고, 교착 상태가 일어날 확률이 높음
- Repeatable_Read
    - 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없음
    - 행이 추가되는 것은 막지 않음 > 추가된 행이 발견될 수 있음
- Read_Committed
    - 커밋 완료된 데이터에 대해서만 조회를 허용
    - 가장 많이 사용되는 격리 수준
    - 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수 있음
- Read_Uncommitted
    - 트랜잭션이 커밋되기 전 다른 트랜잭션에 노출되는 문제가 있음
    - 가장 빠르다
    - 몇몇 행이 제대로 조회되지 않더라도 괜찮은 거대한 양의 데이터를 '어림잡아' 집계하는 데 좋음

격리 수준에 따라 발생하는 현상  
- Phantom Read
    - 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 조회 결과가 다른 경우
    - 예시
        1. 사용자 A가 age가 12 이상인 회원을 조회 > 3개 테이블 조회
        1. 사용자 B가 age가 15인 회원 삽입
        1. 사용자 A가 다시 조회 > 4개 테이블 조회
- Non-Repeatable Read
    - 한 트랜잭션 내의 같은 행에 두 번이상 조회가 발생했는 데, 결과가 다른 경우
    - 예시
        1. 사용자 A가 조회한 회원의 age가 12
        1. 사용자 B가 회원의 age를 15로 변경
        1. 사용자 A가 다시 조회 > age가 15
    - Phantom Read: 다른 행이 선택될 수 있다.  
    Non-Repeatable Read: 행 값이 변경될 수 있다.
- Dirty Read
    - 다른 트랜잭션에 의해 수정되었지만 아직 커밋되지 않은 행의 데이터를 읽을 수 있는 경우

#### 4. 지속성
- 성공적으로 수행된 트랜잭션은 영원히 반영
- 시스템에 장애가 발생해도 원래 상태로 복구하는 회복 기능 필요
    - 체크섬 (중복 검사의 형태. 오류 정정을 통해 송신된 자료의 무결성 보호)
    - 저널링 (변경 사항을 커밋하기 전에 로깅)
    - 롤백

## DB 종류
### 관계형 DB
- 행과 열을 가지는 표 형식의 데이터를 저장
- SQL 언어 활용

#### MySQL
- 대부분의 운영 체제와 호환
- 가장 많이 사용하는 DB (커뮤니티가 잘 발달됨)
- C, C++으로 개발, B-트리 기반의 인덱스, 스레드 기반의 메모리 할당 시스템, 매우 빠른 조인, 최대 64개의 인덱스 제공
- 롤백, 커밋, 이중 암호 지원 보안 등의 기능 제공

#### PostgreSQL
- 데이터 행마다 버전관리가 진행
    - 과거 행을 삭제하고, 변경된 데이터를 추가해야함으로 성능이 좋지 않고, 필요없는 데이터를 장치인 VACUUM 작업이 주기적으로 필요
- 최대 테이블의 크기는 32TB
- SQL, JSON을 이용하여 데이터 접근 가능
- 지정 시간에 복구, 로깅, 접근 제어, 중첩된 트랜잭션, 백업 등의 기능 제공
- 복잡한 쿼리 요구에 유리

### NoSQL DB
- 관계형 DB를 지양하며, 스키마가 없거나 느슨한 스키마를 제공하는 저장소
- 복잡한 구조를 쉽게 저장할 수 있음
- **대량의 분산된 데이터**를 저장하고, 조회하는데 특화됨

#### Key-value 모델
- 가장 기본적인 형태. 저장과 조회라는 가장 간단한 원칙에 충실한 DB.  
- 값에 **모든 데이터 타입을 허용**함 → 개발자들이 데이터 입력 단계에서 검증로직을 제대로 구현해야 함
- Redis. AWS DynamoDB.

#### Document Model
- key-value Model의 확장한 구조. 여기서 문서란 **JSON이나 XML**같은 표준 형식을 가진 문서이다. (Key-Value와 차이점)
- B 트리 인덱스를 사용하여 2차 인덱스를 생성한다. 
    - 쓰기의 성능이 떨어짐
    - 이상적인 상황 = 읽기:쓰기 = 7:3
- MongoDB.

#### **Column Model**
- Row형으로 저장하는 대신 Column으로 저장하는 방식
- 하나의 키에 여러 개의 칼럼 이름과 칼럼 값의 쌍으로 이루어진 데이터를 저장하고 조회
    - 저장의 기본 단위: Column
    - Column 수가 많다면 이를 묶어 Column Family로 구성한다.
- 다수의 클러스터에서 운영된다. 만약 단일서버에서 운영해도 될만큼 데이터가 적다면 적합하지 않다.
- 읽기보다 **쓰기에 특화**되어 있다. 빠른 시간 안에 대량의 데이터를 입력하고 조회하는 서비스를 구현할 때 가장 좋은 성능을 보인다.
- BigTable. Cassandra. HBase.

### 관계형 DB vs NoSQL DB

구분|관계형 DB|NoSQL DB
--|--|--
데이터 저장|SQL을 통해서 테이블에 저장|다양한 형식으로 데이터를 저장
스키마|고정된 형식의 스키마가 필요|동적으로 스키마 형태를 관리
쿼리|테이블 형식과 관계에 맞춰 데이터를 요청(구조화)|데이터 그룹 자체를 조회(비구조화/속도가 느림)
확장성|수직적으로 확장(복잡하고, 시간 많이 소모)|수평적 확장(많은 트래픽 편리하게 관리)
데이터 처리|정렬,탐색,분류가 빠름|쓰기와 읽기 성능이 빠름

#### 관계형 DB를 사용하는 경우
1. ACID 성질을 준수하는 경우
    - 트랜잭션에 의한 상태의 변화를 수행하는 과정에서 안정성을 보장
    - 예외적인 상황을 줄이고, 무결성을 보호
    - 전자 상거래 등에 자주 쓰임
1. 데이터가 구조적이고 일관된 경우
    - 규모가 많은 서버를 필요로 하지 않고 일관된 데이터를 사용하는 경우

#### NoSQL DB를 사용하는 경우
1. 데이터 구조가 거의 없는 대용량 데이터 저장하는 경우
    - 데이터 유형에 제한이 없음
    - 수평적 확장이 가능하여 효율적인 트래픽 처리 가능
1. 빠르게 서비스를 구축하는 과정에서 구조를 자주 업데이트하는 경우
    - 시장에 빠르게 프로토타입을 출시해야하는 경우